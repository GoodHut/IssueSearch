 URL : "https://github.com/JuliaData/Nulls.jl/issues/3" TITLE : performance in structs BODY : very excited to see this! a very basic question: the optimizations for union{t,null} are not in base yet, right? i.e. this is more in prep for once that is there, right? i'm asking because i just compared the following: julia struct foo v::union{float64,null} end struct foo2 v::nullable{float64} end function foo1 a = foo 3. b = foo 2. c = a.v + b.v return c end function foo2 a = foo2 nullable 3. b = foo2 nullable 2. c = get a.v + get b.v return c end when i benchmark these two, i get this: julia> @benchmark foo1 benchmarktools.trial: memory estimate: 16 bytes allocs estimate: 1 -------------- minimum time: 19.018 ns 0.00% gc median time: 20.527 ns 0.00% gc mean time: 22.870 ns 3.06% gc maximum time: 1.201 Î¼s 97.81% gc -------------- samples: 10000 evals/sample: 1000 julia> @benchmark foo2 benchmarktools.trial: memory estimate: 0 bytes allocs estimate: 0 -------------- minimum time: 2.716 ns 0.00% gc median time: 3.019 ns 0.00% gc mean time: 3.292 ns 0.00% gc maximum time: 30.187 ns 0.00% gc -------------- samples: 10000 evals/sample: 1000 the nullable implementation here is almost an order of magnitude faster. i'm pretty sure that i could use union{t,null} for query.jl https://github.com/davidanthoff/query.jl if the kind of example here was as fast as the nullable implementation.