 URL : "https://github.com/python/mypy/issues/4236" TITLE : defaults for generics? BODY : consider the following simplified typeshed definition for email.feedparser.feedparser : python class feedparser: def __init__ self, _factory: callable , message = ... -> none: ... def close self -> message: ... feedparser allows a message factory to be passed in and will use it to construct the return value to close . unfortunately you have to cast the return value of close to the correct type: python parser = feedparser mymessage message = cast mymessage, parser.close the following type definition fixes this problem: python m = typevar m , bound=message class feedparser generic m : def __init__ self, _factory: callable , m = ... -> none: ... def close self -> m: ... now the example above does not require the cast to make mypy happy. but unfortunately using the default factory will not work anymore: python parser = feedparser message = parser.close this will cause mypy to complain error: need type annotation for variable . is there any solution for this conundrum?