 URL : "https://github.com/ThomasRooney/gexpect/issues/28" TITLE : readline cr/lf issue BODY : hey there! ðŸ‘‹ i tried to use gexpect to test a cli app and encountered an issue regarding expected and actual line endings i.e. 0xa / 0xd . on echo 'test ' i was expecting to get test , but unfortunately i get test\r as a return value of the readline function. if my target app outputs multiline go string with as a line separator, i simply can't use the same string as a test expectation since the concatenated result of the reading of all the lines will be separated with \r s. here is a minimal code sample to reproduce: go package main import fmt github.com/thomasrooney/gexpect func main { child, err := gexpect.spawn echo 'test ' if err != nil { panic err } expected := test actual, _ := child.readline fmt.println expected: fmt.printf % v , expected fmt.println fmt.printf % v , byte expected fmt.println ========================= fmt.println actual: fmt.printf % v , actual fmt.println fmt.printf % v , byte actual } on my machine _macos sierra 10.12.2, zsh 5.3, go 1.7.4 darwin/amd64_ it results in: expected: test byte{0x74, 0x65, 0x73, 0x74, 0xa} ========================= actual: test\r byte{0x74, 0x65, 0x73, 0x74, 0xd}% if i change the test string in above code to test\r the result will be: expected: test\r byte{0x74, 0x65, 0x73, 0x74, 0xd} ========================= actual: test\r\r byte{0x74, 0x65, 0x73, 0x74, 0xd, 0xd}