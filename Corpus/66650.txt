 URL : "https://github.com/ThePhD/sol2/issues/406" TITLE : nested movable usertype BODY : hey, first of all thanks for the amazing piece of work, it was a pleasure to it so far! not entirely sure if this is really a bug and even if it is, not sure it is a bug in sol2 but i was able to test it with clang 4.0 and gcc 6.3 using c++14 as well as the partial support for c++17 on arch linux and the error was produced in all cases. consider the following codesnippet the most minimal i could get it : cpp include <sol.hpp> include <iostream> struct somenoncopyable { somenoncopyable = default; // xxx: comment the following 2 lines out to make it work somenoncopyable somenoncopyable&& other noexcept = default; somenoncopyable& operator= somenoncopyable&& other noexcept = default; somenoncopyable const somenoncopyable& other = delete; somenoncopyable& operator= const somenoncopyable& other = delete; }; struct b { somenoncopyable unused; int val {42}; }; struct a { b b; }; int main { sol::state state; state.open_libraries sol::lib::base ; state.new_usertype<b> b , sol::meta_function::construct, sol::no_constructor, val , &b::val ; state.new_usertype<a> a , sol::meta_function::construct, sol::no_constructor, b , &a::b ; // xxx: could use dynamic property here a a {}; state a = &a; state.script print a.b.val ; } i would expect this to at least compile i never actually copy anything but it does not. a workaround i found is simply using a dynamic property for b::val when creating the usertype but i guess it should work this way shouldn't it? but it gets stranger: when commenting out the explicitly defaulted move operator/constructor in somenoncopyable it works. although explicitly defaulting those should not really change anything afaik since the copy operator/constructor is disabled anyways. actually caused me some headache to track this down and have still no clue what this could be. any ideas on this?