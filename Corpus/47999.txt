 URL : "https://github.com/hyperium/hyper/issues/1000" TITLE : redesign the uri type BODY : there are a couple of things that a redesign could help with: - making it an opaque struct instead of an enum means fiddling with internals is no longer a breaking change - it'd be best if we could create less copies when parsing out a uri - to future-proof for when hyper supports http2 we want to optimize for the most common case, which is the origin-form https://tools.ietf.org/html/rfc7230 section-5.3.1 , currently requesturi::absolutepath . we can start with keeping a single string , and then keeping indices into it to know where the path and query are. in http2, the uri would gain additional fields, scheme and authority what is in http1 the host header , and the asterisk-form request target is defined as path = . we could eventually change the internal source representation to be a memslice or whatever it is at that point, to reduce a further copy. some quick code describing what it could look like: rust pub struct uri { source: string, scheme_end: option<usize>, authority_end: option<usize>, query: option<usize>, } impl uri { pub fn path &self -> &str { let index = self.scheme_end.unwrap_or 0 + self.authority_end.unwrap_or 0 ; let end = self.query.unwrap_or self.source.len ; &self.source index..end } // .. and other accessors } let star = uri::from_str .unwrap ; assert_eq! uri { source: string::from , scheme_end: none, authority_end: none, query: none, }, star ; assert_eq! star.path , ; let common = uri::from_str /p?foo=bar .unwrap ; assert_eq! uri { source: string::from /p?foo=bar , scheme_end: none, authority_end: none, query: some 2 , }, common ; assert_eq! common.path , /p ; assert_eq! common.query , ?foo=bar ; cc @guillaumegomez