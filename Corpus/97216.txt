 URL : "https://github.com/DistributedDesigns/worker/issues/8" TITLE : fresh quote race condition BODY : this came up in the 45 user workload. suppose we have a workload like this, where xyz is the first instance of the stock in the workload: n quote,user1,xyz n+1 quote,user2,xyz then this happens: 1. user1 requests xyz -> local cache miss -> request sent to quote manager -> wait for xyz.fresh in rpc queue 1. quote manager cache miss -> new quote from legacy service -> broadcast xyz.fresh 1. user1's rpc queue catches xyz.fresh -> transaction completes 1. in a goroutine worker quote updater catches xyz.fresh -> sends quote to local cache 1. user2 requests xyz -> local cache miss since local cache has not resolved previous update -> request sent to quote manager -> wait for xyz.fresh in rpc queue 1. quote manager cache hit -> broadcast xyz.cache 1. user2 rpc ignores xyz.cache and waits indefinitely i resolved this by having the rpc queue wait for xyz. . it works but i haven't fully thought through the ramifications of pulling down non-fresh quotes. i suspect it's fine for quote but we'll want to preserve the ability to guarantee a fresh quote is caught for stuff like buy that uses quoterequest{ allowcache: false }