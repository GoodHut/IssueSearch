 URL : "https://github.com/weidai11/cryptopp/issues/384" TITLE : vc 2005 x64: BODY : if we do something like this: new rsaes< oaep<cryptopp::sha1> >::decryptor thrng, nkeylen ; _aligned_free will be failed on the x64 target compiled by vc 2005: integer integer::plus const integer& b const { integer sum word 0, stdmax2 reg.size , b.reg.size ; // ... return sum; // <--- here } because, if t_align16 && size sizeof t >= 16 is false so unalignedallocate is used in sum's constructor, but under the destructor, if t_align16 && size sizeof t >= 16 is ture, so aligneddeallocate launched. if i change line typedef secblock<word, allocatorwithcleanup<word, cryptopp_bool_x86> > integersecblock; to typedef secblock<word, allocatorwithcleanup<word, true> > integersecblock; then every thing is fine. could i use this as a temporarily workaround fix ? this bug only occur in msw vc2005 x64. it's fine under msw vc2005 x86 or linux gcc x64/x86.