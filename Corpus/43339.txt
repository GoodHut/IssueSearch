 URL : "https://github.com/Ginko-X/Streaming_NESL/issues/9" TITLE : cost model discussion BODY : the following shows the cost comparison for the program reduceplus {x x : x in &n} , where n ranges in 10 20 30 40 50 60 70 80 90 100 200 300 . the works look reasonable, while the steps are not proportional. i think this is because we implement reduceplus as a primitive at the low level, so it just takes one step instead of logarithmic steps at the high level. ! sqsum https://cloud.githubusercontent.com/assets/5687628/25377481/fec5a720-29a7-11e7-8395-2ee671d32757.jpg another program, prime.snesl count ranges in 10 20 30 40 50 60 70 80 90 100 200 300 : haskell let count = 50; rs1 = {{{x+1 | a / x+1 x+1 == a} : x in &a}: a in &count} ; rs2 = {reduceplus concat z : z in rs1} in concat {{x | x+1 == y}: x in &count, y in rs2} %} and the cost comparison: ! prime https://cloud.githubusercontent.com/assets/5687628/25377482/fec6dc58-29a7-11e7-99f2-daeab6bdbf6b.jpg