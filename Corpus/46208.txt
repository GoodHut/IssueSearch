 URL : "https://github.com/hephaistus/write-up/issues/5" TITLE : lob skeleton -> golem BODY : 문제 ============================== buffer+0x48 뒤의 모든 걸 다 0으로 초기화 시킨다. 풀이 ================================== 계속 고민했으나 도저히 풀지 못해서 힌트를 얻어야 했다. 힌트는 ld_preload. 1. gcc -shared -fpic -o /tmp/ 쉘코드 명 그냥 만들어둔 파일 명 2. export ld_preload= /tmp/ 쉘코드 3. gdb로 golem 분석해서 어디에 쉘코드가 있는지 얻어내보자. 신기하게도 buffer 위에 거의 붙어있다 이때 쉘코드에 \x2f 껴있으면 디렉토리로 인식되어 1번이 잘 실행되지 않으니 적당한 걸로 구해서 할것. ld_preload 설명 ================================== 프로세스 실행 과정 중 라이브러리를 로딩 할때, ld_preload 변수가 설정되어 있으면 해당 변수에 지정된 라이브러리를 먼저 로딩하고, 이중 libc 함수명과 동일한 함수가 있다면 해당 함수를 먼저 호출해 준다. 즉, 자동으로 후킹을 수행하도록 해준다는 말과 같다. 출처: http://hyunmini.tistory.com/55 golem pass ============================= cup of coffee 여담 =========================== ld_preload 를 이용해서 직접 1번 과정을 통해 .so file을 만들어서 해보려고 했다. memset 을 system /bin/sh ; 로 바꾼다던가 해보려고 했는데, /tmp 파일에 복제해둔 golem 으로하면 sh는 뜨지만, my-pass 명령이나 exit 명령이 실행이 안된다. 또 원본 golem에 하면 아예 sh가 뜨지 않는다. 왜 그러는 걸까...????