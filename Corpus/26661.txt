 URL : "https://github.com/JeremySkinner/FluentValidation/issues/516" TITLE : bug: mvc6 + autofac BODY : imo dependency injection via ctor is fine better , but i did also some experiments with property setting. got 2 fv related issues: 1. the onactivating event was raised always after the resolved object was used within ivalidator<t> 2. when i was trying singleinstance , only the 1st call triggered validation no1. the issue is fv and architecture related. if i do add a constructor to the validator and reference there a differrent validator, then that 2nd validator gets resolved, and the onactivating event on that second validator get's called... so this is fine: public employeedetailsdtovalidator ivalidator<employeeaddressdto> employeeaddressdtovalidator, ivalidatorfactory f but the behavior, when the main ivalidator<> is resolved via attribute fvs mvc infrastructure is differrent. no2. i can understand that validators for some reasons must exist per uc. if so, i do really miss this kinda of information from the documentation. some samples: classic registration: services.addmvc .addfluentvalidation fv => { fv.validatorfactorytype = typeof attributedvalidatorfactory ; } ; then separate manual registration with property setter, so if ivalidator<t> has an ihasfactoryproperty interface, then factory property will be set, thus allowing to access other objects... builder .registerassemblytypes validationassemblies .where t => t.isclosedtypeof typeof ivalidator<> .asimplementedinterfaces .onactivating e => { if e.instance is ihasfactoryproperty e.instance as ihasfactoryproperty .factory = e.context.resolve<ivalidatorfactory> ; } .instanceperlifetimescope ;