 URL : "https://github.com/njsmith/trio/issues/6" TITLE : design: thread pools BODY : right now, run_in_worker_thread just always spawns a new thread for the operation, and then kills it after. this might sound ridiculous, but it's not so obviously wrong as it looks! there's a large comment https://github.com/njsmith/trio/blob/6af8e23bf1b522aa2e7aedec8d0bd2fb2d2e4ffb/trio/_threads.py l42-l133 in trio._threads talking about some of the issues. questions: should there be any global control over worker thread spawning? if there is, should it be a strict limit on the number of threads, or something more subtle like a limiter on the rate at which they spawn? how do administrators configure this stuff? or instrument it? what should the api to interact with it look like, e.g. do we need a way for a specific run_in_worker_thread to say that it shouldn't block waiting for a thread because it might unblock a thread? prior art: https://twistedmatrix.com/trac/ticket/5298 > interacting with the products at rackspace which use twisted, i've seen problems caused by thread-pool maximum sizes with some annoying regularity. the basic problem is this: if you have a hard limit on the number of threads, it is not possible to write a correct program which may require starting a new thread to un-block a blocked pool thread - glyph