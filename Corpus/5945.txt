 URL : "https://github.com/gracelang/language/issues/124" TITLE : types in types BODY : i was surprised to find out that we can nest types in objects, but not types in types at least not in a way that they can be used . that is, the following gives an error: type a = { m n:number → number type b = number } def x: a.b = 3 print x interestingly the error does not show up in the type definition, but in its attempted use in the def x statement. on the other hand, the following is fine with the same definition of a . def o: a = object { method m n: number → number {n + 1} type b = number } def y: o.b = 12 print y while i found this discrepancy in minigrace, it corresponds to what i found in the language definition though the language definition doesn't mention embedding type definitions in other type definitions . i would like to see us be consistent and allow type definitions nested in types. we have a couple of choices as to how to handle this esp. in a statically typed dialect . 1 if, as above, a type a includes an embedded definition of type b then any object of type a must also include the same type definition. 2 we could allow some implicit type definitions in an object by declaring an object implements a type. suppose we have the definitions of a and b as above. we could decide to allow the following: def o': a = object { method m n: number → number {n + 1} } def z: o'.b = 12 where o' implicitly picks up the definition of b from the type. ---------- i understand that there might be an argument for allowing more flexibility with a dynamically typed dialect in the language. however, i'm not sure how one would deal with a situation where the type and object have conflicting definitions e.g. in the type b is number, while in the object o:a, the type of b is string , however i'm not sure how that would be resolved dynamically except by just making sure at runtime they are the same type.