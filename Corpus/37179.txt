 URL : "https://github.com/QCoDeS/Qcodes/issues/507" TITLE : leaking sockets ii ? BODY : the metaclass abstraction is leaking sockets, i think. the mwe is hard to make but nonetheless attached , but it's simple to visualise that the side effect of init, via the side effects of a possibly confusingly named set_persistent which will connect a socket by default result in a open socket, that will never be destroyed until the interactive session is over or gc zaps ðŸ‘€ . python bug tester import logging import socket logging.basicconfig level= debug log = logging.getlogger __name__ server = socket.socket socket.af_inet, socket.sock_stream server.bind , 9997 server.listen 5 buffer_size = 1400 dead = 1 def receive sock, eof: bytes : chunks = recv_more = true bytes_recd = 0 while recv_more: chunk = sock.recv buffer_size log.debug got %s , chunk if chunk == b'': logging.info socket closed return 0, dead chunks.append chunk bytes_recd = bytes_recd + len chunk if eof in chunk: recv_more = false log.info recvd %d , bytes_recd return bytes_recd, b''.join chunks while true: log.info start one recv try: client, adresss = server.accept except keyboardinterrupt: server.close break log.info client %s , client while true: try: bytes, msg = receive client, b if bytes == 0 and msg == dead: client.close break client.send msg except keyboardinterrupt: log.info closing break now create two instruments withe the same name: and watch how many connections appear. eventually they may die and get gc, but does seem dangerous. possibly also related to 411 . @alexcjohnson