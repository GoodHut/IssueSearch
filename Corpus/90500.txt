 URL : "https://github.com/jonsterling/racket-grit/issues/25" TITLE : signatures of refinements BODY : i will write down here my ideas about how to deal with refinements properly. first, the current state of affairs is that an atomic refinement like - true / - inh is specified in your lf signature with sort sort . this is not satisfactory, because the states of the refinement engine will not be well-typed: instead, we want to have some notion of refinement that lies over the existing signature, and then presuppose that input states to the refinement engine typecheck at the lf sort that the refinement refines, etc. i think that the simplest thing to do for now is to define a refinement signature as a mapping of symbols/names to lf arities; for instance, we would map inh to arity a exp exp . refinements are not dependent: that is, you can't use a refinement when assigning an arity to a refinement. doing so would correspond to adding support for presuppositions to our framework, and might be interesting in the future, but i think we should not try to account for this at this time, since it's not yet quite clear how to make it work though i can think of a few interesting ideas . things like inh generate the atomic refinements, like plug inh bool , which refine lf sorts in thie case exp ; then, on top of this, we generate the general refinements, which refine lf arities, in a compositional way. all this give rise to a grammar of valid refinements with respect to an lf signature γ and a refinement signature that lies over γ . in addition, it gives rise to an erasure of refinements into lf arities. finally, when we define a prl, we would do something like ambiently set the current lf signature and refinement signature, and using this, we could add contracts or some other kind of check to ensure that the user's defined rules preserve well-typedness.