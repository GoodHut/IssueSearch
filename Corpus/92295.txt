 URL : "https://github.com/alibaba/rax/issues/228" TITLE : weex accessibility 支持 BODY : 经过测试，结果如下： <input class='input' role='search' aria-label='i am a search item'></input> 问题 vue 版 native下正常，h5不正常; 因为 vue版 transfrom 时将属性强制转化为驼峰。 rax版下 使用aria-label，native不正常，h5正常 使用arialabel，native正常，h5不正常 rax版 的 jsx-loader 中未针对此有特殊处理 现状 目前 native 读取的是驼峰（arialabel）的属性（之前约定对所有属性都是驼峰） vue 版的 transfrom 工具会将中划线 aria-label 转化成驼峰 arialabel rax 版的编译工具不做任何转化 用户应该如何使用 针对rax用户，建议遵循业界 react 约定，支持直接写 aria-xx 无障碍属性。原因如下 ! 6fd3f58baa1c3ffe.png https://private-alipayobjects.alipay.com/alipay-rmsdeploy-image/skylark/png/9890/6fd3f58baa1c3ffe.png https://github.com/minwe/style-guide/blob/master/react.js.md 属性命名 ! 27bda85071750530.png https://private-alipayobjects.alipay.com/alipay-rmsdeploy-image/skylark/png/9890/27bda85071750530.png https://react-cn.github.io/react/docs/jsx-gotchas.html -html- 到底在哪里解决此问题合适 前提是用户使用 aria-label ，w3c标准属性 方案一：将源码通过工具 transfrom 成驼峰式 如果像vue一样编译源码时，将属性全部转化为驼峰，那native正常，接下来只需要解决h5下的问题（可通过工具自动编译2份，一份是驼峰版本的for native，一份是中划线版本的for h5） 这有一个缺点是，当用户需要动态修改该属性时，业务代码为了兼容 naitve 和 h5 需要这样写： if isweb { someprops 'aria-label' = '这是一张图片'; } else if isnative { someprops 'arialabel' = '这是一张图片'; } 不管怎样，只要2个端的属性不一致，当需要修改属性时，业务上需要写兼容代码；业务上如果不写兼容代码，那这份运行时的兼容代码就需要放到jsfm底层框架上来。就是以下方案二。 方案二：jsfm 运行时动态兼容 如在rax下，需要过滤所有 element 的 aria-xx 属性，当执行环境是native的容器下时，强制转化为驼峰。 如在vue下，也需要修改jsfm兼容。 方案三：客户端兼容 aria-xx 属性 像 react 一样，虽然react的组件属性规范也是小驼峰，但是它对 aria-xx 也是加白名单的。 建议客户端支持 arialabel ariaxx 的同时兼容 aria-label arialabel ，@梓帆 zifan.zx 这边的成本说很低：） 结论 建议方案三，客户端从根本上保持和 w3c 一致，底层支持 aria-xx 标准属性。 如果客户端直接支持 aria-xx， 对于rax 目前状态，不用做任何处理，业务代码、框架代码、和编译工具等都不用处理；对用户来说，也符合用户预期，没有任何黑盒转化。