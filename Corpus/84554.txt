 URL : "https://github.com/JuliaDiffEq/BoundaryValueDiffEq.jl/issues/12" TITLE : defect control adaptivity BODY : http://epubs.siam.org/doi/pdf/10.1137/s1064827593251496 http://cs.stmarys.ca/~muir/shampinemuirxu2006.pdf http://epubs.siam.org/doi/pdf/10.1137/0912052 the next step should be adaptivity. a really nice way to handle the interpolations in a way that can be used internally is to simply add them to the solution object, and use that solution object on the inside. you can actually see this done in ordinarydiffeq.jl here: https://github.com/juliadiffeq/ordinarydiffeq.jl/blob/master/src/solve.jl l250 so the steps for a defect control are: 1 add a way to call an interpolation scheme on the sol type which is algorithm-dependent . you might want to match ordinarydiffeq.jl for this, though it's quite complicated. we should discuss this. 2 change the timing that the solution is built so it's built before the rest of the routine, and your solver routine just updates the sol.u and sol.t parts this should actually require no change if the pointers are setup correctly! 3 then, the parts of the adaptive algorithm which require using the continuous extension for the defect, you can just call sol t just like a user would . the nice thing about this is that if you get the interpolation on the sol type right, then it'll work both internally and for users just the same. also, this means you can pass the current sol to the bc! , making it exactly the same as the shooting setup and allowing conditions on the interpolation.