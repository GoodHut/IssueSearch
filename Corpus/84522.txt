 URL : "https://github.com/israel-lugo/tsarray/issues/9" TITLE : deal with aliasing issues BODY : we're doing a lot of type magic and pointer casting. this is almost certainly breaking c99 strict aliasing rules, which may lead to undefined behaviour in the face of aggressive optimizations by the compiler. gcc for example is known to aggressively follow a strict interpretation of what may and may not alias under c99 rules, in order to squeeze additional performance out of the code. -fstrict-aliasing is enabled by default at -o2 , which is a conservative setting used almost everywhere. it can be disabled, however, with -fno-strict-aliasing . under strict aliasing rules, the compiler is free to assume, for example, that objects of different types never alias, rendering this undefined behaviour: c include <stdio.h> long foo int x, long y { x = 0; y = 1; return x; } int main { long value; printf %ld , foo int &value, &value ; } gcc assumes that x and y inside foo can never point to the same thing, so it is free to reorder the writes and return 0 unconditionally. meaning the above code will print 1 without optimizations, and 0 with optimizations.