 URL : "https://github.com/MarioAriasC/funKTionale/issues/34" TITLE : either carrying like rust BODY : in rust, the stdlib provides an either like enum called result. functions that return result can also carry values from other result returning functions up the call stack. so if you're performing disk io, where you'll be getting result types as returns based off of whether there was an error opening a file, writing to disk etc. all this can be represented by a macro, or an operator. rust fn i_return_a_result -> result<string, std::io::error> { let i_returned_a_result: file = file_operation_that_returns_result ?; try! write_to_file i_returned_a_result ; ok we did it! .to_string } to those not familiar with rust, let me explain. the function declaration is similar to one you would find in haskell or using funktionale using either, with the difference being that the left side is the result, and the right side is the error, exception, or what have you. in the function body, there were 2 instances where i would have needed to deal with checking that there was a proper value in the result. when i get the file, and when i write i didn't bind a variable in that case, because it's often used that functions return a result with an empty left side, just indicating success . in both cases, were there an error at any pointÂ¸ my function would have stopped executing, and the error from their result would propogate up as the return value of my function, allowing it to be dealt with at the top. would this be at all possible in funcktionale? taking a either returning function and collapsing it down to either give you the value of right, or return from your function with the value of left?